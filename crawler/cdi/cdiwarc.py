#!/usr/local/bin/python3
# Crawl Document Importer for WARC files generated by Heritrix
#
# How to use it
# * Edit configuration file: config.py
# * Edit settings.py to configure database
# 
import os # define invironment variable
import sys 
import django
import output   # defines writer
import logging 
import logging.handlers
import threading
import time
import datetime
import hashlib
#import runconfig # log parser configuration
import settings
os.environ['DJANGO_SETTINGS_MODULE'] = runconfig.django_settings_module
from subprocess import call
import filter_doc
import commands
import string 
import StringIO
import glob
import urllib
import logparsers # log parser module
import counter 
import textextract
import crawldb
import printinfo
import timeoutpython
import urlfilters
from exception import BadResourceError
import _mysql_exceptions
from cdilib import id_to_fname,create_instance
from check_config import checkConfig
from datetimelib_jwu import getcurrentdatetime_trim,getcurrentdatetime_db
from readyesno import read_yes_no
from optparse import OptionParser
from conf import Config_global
from warc_processor import WARC_processor
import resource # define resource variable "r"
# main 
def main(jobid,verbose=False):

    # record start time 
    tic = time.time()
  
    # create on-screen information printer
    infoprinter = printinfo.printInfo()
  
    # check configurations
    config = Config_global(jobid)
    config.check_config()
    config.open_logw()
    if verbose: print "jobid: %(1)s"%{"1":config.jobid}

    # create the WARC_professor object
    warcproc = WARC_processor(config)

    #   from os import listdir
    warcfiles = warcproc.get_warcs()

    if warcfiles:
        for wf in warcfiles:
            # decompress before extraction will increase speed
            wf_path = unzip_gz(wf,verbose=verbose) if wf.endswith(".gz") else wf
            warcproc.extract_all(wf_path,verbose=verbose)
            # delete after extraction
            if config.delete_after_import: delete_file(wf_path)

    # close log file
    config.close_logw()
    

    # print counters in a new line
    warcproc.counters.printCounter()
    warcproc.counters.printCountertoFile(config.sum_file)

    # record end time to calculate processing time
    # because strftime() will truncate the time string when converting to the
    # user-defined time format, we add "1" second to compensate this loss. 
    toc = time.time()
    processingtime = time.strftime('%H:%M:%S',time.gmtime(toc-tic+1))
    infoprinter.printPara("warc files",str(len(warcfiles)))
    infoprinter.printPara('Processing time',processingtime)
    print 'end importing from directory: ',config.crawler_dir
    print 'logfile output to: ',config.log_file

# delete a file, add double quote in case file name contains space 
def delete_file(file_path): 
    output = commands.getoutput('rm -rf "%(1)s"'%{"1":file_path})

# unzip a .gz file and return the file path after decompression
def unzip_gz(gzipfile,verbose=False):
    unzippedfile =os.path.splitext(gzipfile)[0]
    if verbose: print "unzipping: %(1)s > %(2)s"%\
           {"1":os.path.split(gzipfile)[1],"2":os.path.split(unzippedfile)[1]}
    if gzipfile.endswith(".gz"):
        shell_cmd = "gunzip %(1)s"%{"1":gzipfile}
        shell_out = commands.getoutput(shell_cmd)

        return unzippedfile
    else:
        if verbose: print "not a gzipped file, keep original name: ",gzipfile

        return gzipfile
    

# accept input parameters
parser = argparse.ArgumentParser()
# a positional argument
#parser.add_argument("outputfile",metavar="OUTPUTFILE",type=str,help="The text file containing csxdois that are not in CiteSeerX repository")
# an optional argument
parser.add_argument("-j","--jobid",dest="jobid",help="name CDI log to JOBID.",metavar="JOBID")
# an optional argument with a shortcut
parser.add_argument("-v","--verbose",help="increase output verbosity",action="store_true",dest="verbose",default=False)
# parser.add_argument("--infile",metavar="INFILE",help="The input file containing a list of csxdois",type=str)
# logdir
parser.add_argument("--logdir",help="The directory to save log files. Logs are saved to ~/logs/ by default.",default='~/logs')
args = parser.parse_args()
if args.verbose:
    logging_level = logging.DEBUG
else:
    logging_level = logging.INFO

# logging configurations
if args.logdir == "~/logs":
    usedef = input("No logdir provided, use default? [Y/N] {} \n".format(args.logdir))
    if usedef == "Y":
        args.logdir = os.path.join(expanduser("~"),"logs")
    elif usedef == "N":
        os.exit("Please specify a valid logdir. ")
    else:
        os.exit("Invalid input.")

if not os.path.exists(args.logdir):
    print("logdir not exist")
    os.makedirs(args.logdir)
else:
    print("logdir = {}".format(args.logdir))

logging.basicConfig(level=logging_level,\
              filename=os.path.join(args.logdir,"cdiwarc.log"),\
              format="%(asctime)s %(name)-10s %(levelname)-8s %(message)s",
              filemode="a")
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(name)-10s %(levelname)-8s %(message)s")
console.setFormatter(formatter)
logging.getLogger("").addHandler(console)
logging.debug("logging configuration done")

parser = OptionParser()
parser.add_option("-j","--jobid",dest="jobid",\
                 help="name CDI log to JOBID",metavar="JOBID")
parser.add_option("-q","--quite",\
                 action="store_false",dest="verbose",default=True,\
                 help="don't print detailed message to stdout")
 
# You can input a string as the "jobid", if you do not input anything,
# the program uses the Heritrix job ID as the "jobid"
if __name__=="__main__":
    main(jobid=args.jobid,verbose=args.verbose)
